"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _MeasurementDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    location: "LocationDict"
    time: str
    variable: "VariableDict"


class MeasurementDict(_MeasurementDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    value: typing.Optional[float]
    source: typing.Optional["SourceDict"]


class TMeasurement(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Merenje

    Attrs:
        id: Identifikacioni broj (interni ključ)
        location: The location of the Measurement.
        time: Vreme merenja
        variable: The variable of the Measurement.
        value: Vrednost meteorološke promenljive
        source: The source of the Measurement.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    location: 'sqlalchemy.Column["TLocation"]'
    time: 'sqlalchemy.Column[datetime.datetime]'
    variable: 'sqlalchemy.Column["TVariable"]'
    value: 'sqlalchemy.Column[typing.Optional[float]]'
    source: 'sqlalchemy.Column[typing.Optional["TSource"]]'

    def __init__(self, location: "TLocation", time: datetime.datetime, variable: "TVariable", id: typing.Optional[int] = None, value: typing.Optional[float] = None, source: typing.Optional["TSource"] = None) -> None:
        """
        Construct.

        Args:
            id: Identifikacioni broj (interni ključ)
            location: The location of the Measurement.
            time: Vreme merenja
            variable: The variable of the Measurement.
            value: Vrednost meteorološke promenljive
            source: The source of the Measurement.

        """
        ...

    @classmethod
    def from_dict(cls, location: "LocationDict", time: datetime.datetime, variable: "VariableDict", id: typing.Optional[int] = None, value: typing.Optional[float] = None, source: typing.Optional["SourceDict"] = None) -> "TMeasurement":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Identifikacioni broj (interni ključ)
            location: The location of the Measurement.
            time: Vreme merenja
            variable: The variable of the Measurement.
            value: Vrednost meteorološke promenljive
            source: The source of the Measurement.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TMeasurement":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> MeasurementDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Measurement: typing.Type[TMeasurement] = models.Measurement  # type: ignore


class _LocationDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    country: str
    lat: float
    long: float
    stanica: "StanicaDict"


class LocationDict(_LocationDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TLocation(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Lokacija na kojoj je izmerena promenljiva

    Attrs:
        id: Identifikacioni broj (interni ključ)
        name: Naziv lokacije
        country: Država lokacije
        lat: Geografska širina
        long: Geografska dužina
        stanica: The stanica of the Location.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    country: 'sqlalchemy.Column[str]'
    lat: 'sqlalchemy.Column[float]'
    long: 'sqlalchemy.Column[float]'
    stanica: 'sqlalchemy.Column["TStanica"]'

    def __init__(self, name: str, country: str, lat: float, long: float, stanica: "TStanica", id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: Identifikacioni broj (interni ključ)
            name: Naziv lokacije
            country: Država lokacije
            lat: Geografska širina
            long: Geografska dužina
            stanica: The stanica of the Location.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, country: str, lat: float, long: float, stanica: "StanicaDict", id: typing.Optional[int] = None) -> "TLocation":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Identifikacioni broj (interni ključ)
            name: Naziv lokacije
            country: Država lokacije
            lat: Geografska širina
            long: Geografska dužina
            stanica: The stanica of the Location.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TLocation":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> LocationDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Location: typing.Type[TLocation] = models.Location  # type: ignore


class _VariableDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class VariableDict(_VariableDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TVariable(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Meteorološka promenljiva

    Attrs:
        id: Identifikacioni broj (interni ključ)
        name: Naziv meteorološke promenljive

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'

    def __init__(self, name: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: Identifikacioni broj (interni ključ)
            name: Naziv meteorološke promenljive

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None) -> "TVariable":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Identifikacioni broj (interni ključ)
            name: Naziv meteorološke promenljive

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TVariable":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> VariableDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Variable: typing.Type[TVariable] = models.Variable  # type: ignore


class SourceDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    code: typing.Optional[str]
    name: typing.Optional[str]


class TSource(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Naziv izvora

    Attrs:
        id: Identifikacioni broj (ključ)
        code: Kod (skraćeni naziv)
        name: Naziv izvora

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    code: 'sqlalchemy.Column[typing.Optional[str]]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, code: typing.Optional[str] = None, name: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: Identifikacioni broj (ključ)
            code: Kod (skraćeni naziv)
            name: Naziv izvora

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, code: typing.Optional[str] = None, name: typing.Optional[str] = None) -> "TSource":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Identifikacioni broj (ključ)
            code: Kod (skraćeni naziv)
            name: Naziv izvora

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TSource":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> SourceDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Source: typing.Type[TSource] = models.Source  # type: ignore


class StanicaDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    naziv: typing.Optional[str]
    tip: typing.Optional[str]


class TStanica(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Stanica na kojoj je mereno

    Attrs:
        id: Identifikacioni broj (ključ)
        naziv: Naziv stanice
        tip: Tip stanice

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    naziv: 'sqlalchemy.Column[typing.Optional[str]]'
    tip: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, naziv: typing.Optional[str] = None, tip: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: Identifikacioni broj (ključ)
            naziv: Naziv stanice
            tip: Tip stanice

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, naziv: typing.Optional[str] = None, tip: typing.Optional[str] = None) -> "TStanica":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Identifikacioni broj (ključ)
            naziv: Naziv stanice
            tip: Tip stanice

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TStanica":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> StanicaDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Stanica: typing.Type[TStanica] = models.Stanica  # type: ignore
